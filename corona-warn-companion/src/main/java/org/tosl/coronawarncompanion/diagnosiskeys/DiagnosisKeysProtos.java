// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: org/tosl/coronawarncompanion/diagnosiskeys/TemporaryExposureKeyExportV1_5.proto

package org.tosl.coronawarncompanion.diagnosiskeys;

public final class DiagnosisKeysProtos {
  private DiagnosisKeysProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface TemporaryExposureKeyExportOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TemporaryExposureKeyExport)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     * @return Whether the startTimestamp field is set.
     */
    boolean hasStartTimestamp();
    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     * @return The startTimestamp.
     */
    long getStartTimestamp();

    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     * @return Whether the endTimestamp field is set.
     */
    boolean hasEndTimestamp();
    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     * @return The endTimestamp.
     */
    long getEndTimestamp();

    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return Whether the region field is set.
     */
    boolean hasRegion();
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return The region.
     */
    java.lang.String getRegion();
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return The bytes for region.
     */
    com.google.protobuf.ByteString
        getRegionBytes();

    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     * @return Whether the batchNum field is set.
     */
    boolean hasBatchNum();
    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     * @return The batchNum.
     */
    int getBatchNum();

    /**
     * <code>optional int32 batch_size = 5;</code>
     * @return Whether the batchSize field is set.
     */
    boolean hasBatchSize();
    /**
     * <code>optional int32 batch_size = 5;</code>
     * @return The batchSize.
     */
    int getBatchSize();

    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> 
        getSignatureInfosList();
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfos(int index);
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    int getSignatureInfosCount();

    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> 
        getKeysList();
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getKeys(int index);
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    int getKeysCount();

    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> 
        getRevisedKeysList();
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getRevisedKeys(int index);
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    int getRevisedKeysCount();
  }
  /**
   * <pre>
   * Protobuf definition for exports of confirmed temporary exposure keys.
   * The full file format is documented under "Exposure Key Export File Format
   * and Verification" at https://www.google.com/covid19/exposurenotifications/
   * These files have a 16-byte, space-padded header before the protobuf data
   * starts. They will be contained in a zip archive, alongside a signature
   * file verifying the contents.
   * </pre>
   *
   * Protobuf type {@code TemporaryExposureKeyExport}
   */
  public  static final class TemporaryExposureKeyExport extends
      com.google.protobuf.GeneratedMessageLite<
          TemporaryExposureKeyExport, TemporaryExposureKeyExport.Builder> implements
      // @@protoc_insertion_point(message_implements:TemporaryExposureKeyExport)
      TemporaryExposureKeyExportOrBuilder {
    private TemporaryExposureKeyExport() {
      region_ = "";
      signatureInfos_ = emptyProtobufList();
      keys_ = emptyProtobufList();
      revisedKeys_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int START_TIMESTAMP_FIELD_NUMBER = 1;
    private long startTimestamp_;
    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     * @return Whether the startTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasStartTimestamp() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     * @return The startTimestamp.
     */
    @java.lang.Override
    public long getStartTimestamp() {
      return startTimestamp_;
    }
    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     * @param value The startTimestamp to set.
     */
    private void setStartTimestamp(long value) {
      bitField0_ |= 0x00000001;
      startTimestamp_ = value;
    }
    /**
     * <pre>
     * Time window of keys in this file based on arrival to server, in UTC
     * seconds
     * </pre>
     *
     * <code>optional fixed64 start_timestamp = 1;</code>
     */
    private void clearStartTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000001);
      startTimestamp_ = 0L;
    }

    public static final int END_TIMESTAMP_FIELD_NUMBER = 2;
    private long endTimestamp_;
    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     * @return Whether the endTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasEndTimestamp() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     * @return The endTimestamp.
     */
    @java.lang.Override
    public long getEndTimestamp() {
      return endTimestamp_;
    }
    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     * @param value The endTimestamp to set.
     */
    private void setEndTimestamp(long value) {
      bitField0_ |= 0x00000002;
      endTimestamp_ = value;
    }
    /**
     * <code>optional fixed64 end_timestamp = 2;</code>
     */
    private void clearEndTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000002);
      endTimestamp_ = 0L;
    }

    public static final int REGION_FIELD_NUMBER = 3;
    private java.lang.String region_;
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return Whether the region field is set.
     */
    @java.lang.Override
    public boolean hasRegion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return The region.
     */
    @java.lang.Override
    public java.lang.String getRegion() {
      return region_;
    }
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @return The bytes for region.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRegionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(region_);
    }
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @param value The region to set.
     */
    private void setRegion(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000004;
      region_ = value;
    }
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     */
    private void clearRegion() {
      bitField0_ = (bitField0_ & ~0x00000004);
      region_ = getDefaultInstance().getRegion();
    }
    /**
     * <pre>
     * Region for which these keys came from (e.g., country)
     * </pre>
     *
     * <code>optional string region = 3;</code>
     * @param value The bytes for region to set.
     */
    private void setRegionBytes(
        com.google.protobuf.ByteString value) {
      region_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static final int BATCH_NUM_FIELD_NUMBER = 4;
    private int batchNum_;
    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     * @return Whether the batchNum field is set.
     */
    @java.lang.Override
    public boolean hasBatchNum() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     * @return The batchNum.
     */
    @java.lang.Override
    public int getBatchNum() {
      return batchNum_;
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     * @param value The batchNum to set.
     */
    private void setBatchNum(int value) {
      bitField0_ |= 0x00000008;
      batchNum_ = value;
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
     * Note: Not yet supported on iOS. Use values of 1 for both.
     * </pre>
     *
     * <code>optional int32 batch_num = 4;</code>
     */
    private void clearBatchNum() {
      bitField0_ = (bitField0_ & ~0x00000008);
      batchNum_ = 0;
    }

    public static final int BATCH_SIZE_FIELD_NUMBER = 5;
    private int batchSize_;
    /**
     * <code>optional int32 batch_size = 5;</code>
     * @return Whether the batchSize field is set.
     */
    @java.lang.Override
    public boolean hasBatchSize() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional int32 batch_size = 5;</code>
     * @return The batchSize.
     */
    @java.lang.Override
    public int getBatchSize() {
      return batchSize_;
    }
    /**
     * <code>optional int32 batch_size = 5;</code>
     * @param value The batchSize to set.
     */
    private void setBatchSize(int value) {
      bitField0_ |= 0x00000010;
      batchSize_ = value;
    }
    /**
     * <code>optional int32 batch_size = 5;</code>
     */
    private void clearBatchSize() {
      bitField0_ = (bitField0_ & ~0x00000010);
      batchSize_ = 0;
    }

    public static final int SIGNATURE_INFOS_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> signatureInfos_;
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    @java.lang.Override
    public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> getSignatureInfosList() {
      return signatureInfos_;
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    public java.util.List<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfoOrBuilder> 
        getSignatureInfosOrBuilderList() {
      return signatureInfos_;
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    @java.lang.Override
    public int getSignatureInfosCount() {
      return signatureInfos_.size();
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfos(int index) {
      return signatureInfos_.get(index);
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfoOrBuilder getSignatureInfosOrBuilder(
        int index) {
      return signatureInfos_.get(index);
    }
    private void ensureSignatureInfosIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> tmp = signatureInfos_;
      if (!tmp.isModifiable()) {
        signatureInfos_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void setSignatureInfos(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
      value.getClass();
  ensureSignatureInfosIsMutable();
      signatureInfos_.set(index, value);
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void addSignatureInfos(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
      value.getClass();
  ensureSignatureInfosIsMutable();
      signatureInfos_.add(value);
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void addSignatureInfos(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
      value.getClass();
  ensureSignatureInfosIsMutable();
      signatureInfos_.add(index, value);
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void addAllSignatureInfos(
        java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> values) {
      ensureSignatureInfosIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, signatureInfos_);
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void clearSignatureInfos() {
      signatureInfos_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Information about signatures
     * </pre>
     *
     * <code>repeated .SignatureInfo signature_infos = 6;</code>
     */
    private void removeSignatureInfos(int index) {
      ensureSignatureInfosIsMutable();
      signatureInfos_.remove(index);
    }

    public static final int KEYS_FIELD_NUMBER = 7;
    private com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> keys_;
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    @java.lang.Override
    public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> getKeysList() {
      return keys_;
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    public java.util.List<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyOrBuilder> 
        getKeysOrBuilderList() {
      return keys_;
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    @java.lang.Override
    public int getKeysCount() {
      return keys_.size();
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getKeys(int index) {
      return keys_.get(index);
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyOrBuilder getKeysOrBuilder(
        int index) {
      return keys_.get(index);
    }
    private void ensureKeysIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> tmp = keys_;
      if (!tmp.isModifiable()) {
        keys_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void setKeys(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureKeysIsMutable();
      keys_.set(index, value);
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void addKeys(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureKeysIsMutable();
      keys_.add(value);
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void addKeys(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureKeysIsMutable();
      keys_.add(index, value);
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void addAllKeys(
        java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> values) {
      ensureKeysIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, keys_);
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void clearKeys() {
      keys_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The TemporaryExposureKeys for initial release of keys.
     * Keys should be included in this list for initial release,
     * whereas revised or revoked keys should go in revised_keys.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey keys = 7;</code>
     */
    private void removeKeys(int index) {
      ensureKeysIsMutable();
      keys_.remove(index);
    }

    public static final int REVISED_KEYS_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> revisedKeys_;
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    @java.lang.Override
    public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> getRevisedKeysList() {
      return revisedKeys_;
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    public java.util.List<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyOrBuilder> 
        getRevisedKeysOrBuilderList() {
      return revisedKeys_;
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    @java.lang.Override
    public int getRevisedKeysCount() {
      return revisedKeys_.size();
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getRevisedKeys(int index) {
      return revisedKeys_.get(index);
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyOrBuilder getRevisedKeysOrBuilder(
        int index) {
      return revisedKeys_.get(index);
    }
    private void ensureRevisedKeysIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> tmp = revisedKeys_;
      if (!tmp.isModifiable()) {
        revisedKeys_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void setRevisedKeys(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureRevisedKeysIsMutable();
      revisedKeys_.set(index, value);
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void addRevisedKeys(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureRevisedKeysIsMutable();
      revisedKeys_.add(value);
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void addRevisedKeys(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
      value.getClass();
  ensureRevisedKeysIsMutable();
      revisedKeys_.add(index, value);
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void addAllRevisedKeys(
        java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> values) {
      ensureRevisedKeysIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, revisedKeys_);
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void clearRevisedKeys() {
      revisedKeys_ = emptyProtobufList();
    }
    /**
     * <pre>
     * TemporaryExposureKeys that have changed status.
     * Keys should be included in this list if they have changed status
     * or have been revoked.
     * </pre>
     *
     * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
     */
    private void removeRevisedKeys(int index) {
      ensureRevisedKeysIsMutable();
      revisedKeys_.remove(index);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Protobuf definition for exports of confirmed temporary exposure keys.
     * The full file format is documented under "Exposure Key Export File Format
     * and Verification" at https://www.google.com/covid19/exposurenotifications/
     * These files have a 16-byte, space-padded header before the protobuf data
     * starts. They will be contained in a zip archive, alongside a signature
     * file verifying the contents.
     * </pre>
     *
     * Protobuf type {@code TemporaryExposureKeyExport}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport, Builder> implements
        // @@protoc_insertion_point(builder_implements:TemporaryExposureKeyExport)
        org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExportOrBuilder {
      // Construct using org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Time window of keys in this file based on arrival to server, in UTC
       * seconds
       * </pre>
       *
       * <code>optional fixed64 start_timestamp = 1;</code>
       * @return Whether the startTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasStartTimestamp() {
        return instance.hasStartTimestamp();
      }
      /**
       * <pre>
       * Time window of keys in this file based on arrival to server, in UTC
       * seconds
       * </pre>
       *
       * <code>optional fixed64 start_timestamp = 1;</code>
       * @return The startTimestamp.
       */
      @java.lang.Override
      public long getStartTimestamp() {
        return instance.getStartTimestamp();
      }
      /**
       * <pre>
       * Time window of keys in this file based on arrival to server, in UTC
       * seconds
       * </pre>
       *
       * <code>optional fixed64 start_timestamp = 1;</code>
       * @param value The startTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setStartTimestamp(long value) {
        copyOnWrite();
        instance.setStartTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Time window of keys in this file based on arrival to server, in UTC
       * seconds
       * </pre>
       *
       * <code>optional fixed64 start_timestamp = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTimestamp() {
        copyOnWrite();
        instance.clearStartTimestamp();
        return this;
      }

      /**
       * <code>optional fixed64 end_timestamp = 2;</code>
       * @return Whether the endTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasEndTimestamp() {
        return instance.hasEndTimestamp();
      }
      /**
       * <code>optional fixed64 end_timestamp = 2;</code>
       * @return The endTimestamp.
       */
      @java.lang.Override
      public long getEndTimestamp() {
        return instance.getEndTimestamp();
      }
      /**
       * <code>optional fixed64 end_timestamp = 2;</code>
       * @param value The endTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setEndTimestamp(long value) {
        copyOnWrite();
        instance.setEndTimestamp(value);
        return this;
      }
      /**
       * <code>optional fixed64 end_timestamp = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEndTimestamp() {
        copyOnWrite();
        instance.clearEndTimestamp();
        return this;
      }

      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @return Whether the region field is set.
       */
      @java.lang.Override
      public boolean hasRegion() {
        return instance.hasRegion();
      }
      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @return The region.
       */
      @java.lang.Override
      public java.lang.String getRegion() {
        return instance.getRegion();
      }
      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @return The bytes for region.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRegionBytes() {
        return instance.getRegionBytes();
      }
      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @param value The region to set.
       * @return This builder for chaining.
       */
      public Builder setRegion(
          java.lang.String value) {
        copyOnWrite();
        instance.setRegion(value);
        return this;
      }
      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRegion() {
        copyOnWrite();
        instance.clearRegion();
        return this;
      }
      /**
       * <pre>
       * Region for which these keys came from (e.g., country)
       * </pre>
       *
       * <code>optional string region = 3;</code>
       * @param value The bytes for region to set.
       * @return This builder for chaining.
       */
      public Builder setRegionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRegionBytes(value);
        return this;
      }

      /**
       * <pre>
       * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
       * Note: Not yet supported on iOS. Use values of 1 for both.
       * </pre>
       *
       * <code>optional int32 batch_num = 4;</code>
       * @return Whether the batchNum field is set.
       */
      @java.lang.Override
      public boolean hasBatchNum() {
        return instance.hasBatchNum();
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
       * Note: Not yet supported on iOS. Use values of 1 for both.
       * </pre>
       *
       * <code>optional int32 batch_num = 4;</code>
       * @return The batchNum.
       */
      @java.lang.Override
      public int getBatchNum() {
        return instance.getBatchNum();
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
       * Note: Not yet supported on iOS. Use values of 1 for both.
       * </pre>
       *
       * <code>optional int32 batch_num = 4;</code>
       * @param value The batchNum to set.
       * @return This builder for chaining.
       */
      public Builder setBatchNum(int value) {
        copyOnWrite();
        instance.setBatchNum(value);
        return this;
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10. Ordinal, 1-based numbering.
       * Note: Not yet supported on iOS. Use values of 1 for both.
       * </pre>
       *
       * <code>optional int32 batch_num = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchNum() {
        copyOnWrite();
        instance.clearBatchNum();
        return this;
      }

      /**
       * <code>optional int32 batch_size = 5;</code>
       * @return Whether the batchSize field is set.
       */
      @java.lang.Override
      public boolean hasBatchSize() {
        return instance.hasBatchSize();
      }
      /**
       * <code>optional int32 batch_size = 5;</code>
       * @return The batchSize.
       */
      @java.lang.Override
      public int getBatchSize() {
        return instance.getBatchSize();
      }
      /**
       * <code>optional int32 batch_size = 5;</code>
       * @param value The batchSize to set.
       * @return This builder for chaining.
       */
      public Builder setBatchSize(int value) {
        copyOnWrite();
        instance.setBatchSize(value);
        return this;
      }
      /**
       * <code>optional int32 batch_size = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchSize() {
        copyOnWrite();
        instance.clearBatchSize();
        return this;
      }

      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      @java.lang.Override
      public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> getSignatureInfosList() {
        return java.util.Collections.unmodifiableList(
            instance.getSignatureInfosList());
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      @java.lang.Override
      public int getSignatureInfosCount() {
        return instance.getSignatureInfosCount();
      }/**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfos(int index) {
        return instance.getSignatureInfos(index);
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder setSignatureInfos(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
        copyOnWrite();
        instance.setSignatureInfos(index, value);
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder setSignatureInfos(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setSignatureInfos(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder addSignatureInfos(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
        copyOnWrite();
        instance.addSignatureInfos(value);
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder addSignatureInfos(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
        copyOnWrite();
        instance.addSignatureInfos(index, value);
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder addSignatureInfos(
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addSignatureInfos(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder addSignatureInfos(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addSignatureInfos(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder addAllSignatureInfos(
          java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> values) {
        copyOnWrite();
        instance.addAllSignatureInfos(values);
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder clearSignatureInfos() {
        copyOnWrite();
        instance.clearSignatureInfos();
        return this;
      }
      /**
       * <pre>
       * Information about signatures
       * </pre>
       *
       * <code>repeated .SignatureInfo signature_infos = 6;</code>
       */
      public Builder removeSignatureInfos(int index) {
        copyOnWrite();
        instance.removeSignatureInfos(index);
        return this;
      }

      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      @java.lang.Override
      public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> getKeysList() {
        return java.util.Collections.unmodifiableList(
            instance.getKeysList());
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      @java.lang.Override
      public int getKeysCount() {
        return instance.getKeysCount();
      }/**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getKeys(int index) {
        return instance.getKeys(index);
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder setKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.setKeys(index, value);
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder setKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.setKeys(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder addKeys(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.addKeys(value);
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder addKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.addKeys(index, value);
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder addKeys(
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.addKeys(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder addKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.addKeys(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder addAllKeys(
          java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> values) {
        copyOnWrite();
        instance.addAllKeys(values);
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder clearKeys() {
        copyOnWrite();
        instance.clearKeys();
        return this;
      }
      /**
       * <pre>
       * The TemporaryExposureKeys for initial release of keys.
       * Keys should be included in this list for initial release,
       * whereas revised or revoked keys should go in revised_keys.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey keys = 7;</code>
       */
      public Builder removeKeys(int index) {
        copyOnWrite();
        instance.removeKeys(index);
        return this;
      }

      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      @java.lang.Override
      public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> getRevisedKeysList() {
        return java.util.Collections.unmodifiableList(
            instance.getRevisedKeysList());
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      @java.lang.Override
      public int getRevisedKeysCount() {
        return instance.getRevisedKeysCount();
      }/**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getRevisedKeys(int index) {
        return instance.getRevisedKeys(index);
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder setRevisedKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.setRevisedKeys(index, value);
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder setRevisedKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.setRevisedKeys(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder addRevisedKeys(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.addRevisedKeys(value);
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder addRevisedKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey value) {
        copyOnWrite();
        instance.addRevisedKeys(index, value);
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder addRevisedKeys(
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.addRevisedKeys(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder addRevisedKeys(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.Builder builderForValue) {
        copyOnWrite();
        instance.addRevisedKeys(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder addAllRevisedKeys(
          java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> values) {
        copyOnWrite();
        instance.addAllRevisedKeys(values);
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder clearRevisedKeys() {
        copyOnWrite();
        instance.clearRevisedKeys();
        return this;
      }
      /**
       * <pre>
       * TemporaryExposureKeys that have changed status.
       * Keys should be included in this list if they have changed status
       * or have been revoked.
       * </pre>
       *
       * <code>repeated .TemporaryExposureKey revised_keys = 8;</code>
       */
      public Builder removeRevisedKeys(int index) {
        copyOnWrite();
        instance.removeRevisedKeys(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:TemporaryExposureKeyExport)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "startTimestamp_",
              "endTimestamp_",
              "region_",
              "batchNum_",
              "batchSize_",
              "signatureInfos_",
              org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.class,
              "keys_",
              org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.class,
              "revisedKeys_",
              org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.class,
            };
            java.lang.String info =
                "\u0001\b\u0000\u0001\u0001\b\b\u0000\u0003\u0000\u0001\u1005\u0000\u0002\u1005\u0001" +
                "\u0003\u1008\u0002\u0004\u1004\u0003\u0005\u1004\u0004\u0006\u001b\u0007\u001b\b" +
                "\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport> parser = PARSER;
          if (parser == null) {
            synchronized (org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:TemporaryExposureKeyExport)
    private static final org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport DEFAULT_INSTANCE;
    static {
      TemporaryExposureKeyExport defaultInstance = new TemporaryExposureKeyExport();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TemporaryExposureKeyExport.class, defaultInstance);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyExport getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TemporaryExposureKeyExport> PARSER;

    public static com.google.protobuf.Parser<TemporaryExposureKeyExport> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignatureInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:SignatureInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return Whether the verificationKeyVersion field is set.
     */
    boolean hasVerificationKeyVersion();
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return The verificationKeyVersion.
     */
    java.lang.String getVerificationKeyVersion();
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return The bytes for verificationKeyVersion.
     */
    com.google.protobuf.ByteString
        getVerificationKeyVersionBytes();

    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return Whether the verificationKeyId field is set.
     */
    boolean hasVerificationKeyId();
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return The verificationKeyId.
     */
    java.lang.String getVerificationKeyId();
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return The bytes for verificationKeyId.
     */
    com.google.protobuf.ByteString
        getVerificationKeyIdBytes();

    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    boolean hasSignatureAlgorithm();
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return The signatureAlgorithm.
     */
    java.lang.String getSignatureAlgorithm();
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return The bytes for signatureAlgorithm.
     */
    com.google.protobuf.ByteString
        getSignatureAlgorithmBytes();
  }
  /**
   * Protobuf type {@code SignatureInfo}
   */
  public  static final class SignatureInfo extends
      com.google.protobuf.GeneratedMessageLite<
          SignatureInfo, SignatureInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:SignatureInfo)
      SignatureInfoOrBuilder {
    private SignatureInfo() {
      verificationKeyVersion_ = "";
      verificationKeyId_ = "";
      signatureAlgorithm_ = "";
    }
    private int bitField0_;
    public static final int VERIFICATION_KEY_VERSION_FIELD_NUMBER = 3;
    private java.lang.String verificationKeyVersion_;
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return Whether the verificationKeyVersion field is set.
     */
    @java.lang.Override
    public boolean hasVerificationKeyVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return The verificationKeyVersion.
     */
    @java.lang.Override
    public java.lang.String getVerificationKeyVersion() {
      return verificationKeyVersion_;
    }
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @return The bytes for verificationKeyVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVerificationKeyVersionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(verificationKeyVersion_);
    }
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @param value The verificationKeyVersion to set.
     */
    private void setVerificationKeyVersion(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      verificationKeyVersion_ = value;
    }
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     */
    private void clearVerificationKeyVersion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      verificationKeyVersion_ = getDefaultInstance().getVerificationKeyVersion();
    }
    /**
     * <pre>
     * Key version for rollovers
     * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
     * </pre>
     *
     * <code>optional string verification_key_version = 3;</code>
     * @param value The bytes for verificationKeyVersion to set.
     */
    private void setVerificationKeyVersionBytes(
        com.google.protobuf.ByteString value) {
      verificationKeyVersion_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int VERIFICATION_KEY_ID_FIELD_NUMBER = 4;
    private java.lang.String verificationKeyId_;
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return Whether the verificationKeyId field is set.
     */
    @java.lang.Override
    public boolean hasVerificationKeyId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return The verificationKeyId.
     */
    @java.lang.Override
    public java.lang.String getVerificationKeyId() {
      return verificationKeyId_;
    }
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @return The bytes for verificationKeyId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVerificationKeyIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(verificationKeyId_);
    }
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @param value The verificationKeyId to set.
     */
    private void setVerificationKeyId(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000002;
      verificationKeyId_ = value;
    }
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     */
    private void clearVerificationKeyId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      verificationKeyId_ = getDefaultInstance().getVerificationKeyId();
    }
    /**
     * <pre>
     * Alias with which to identify public key to be used for verification
     * Must be in character class [a-zA-Z0-9_]
     * For cross-compatibility with Apple, use MCC
     * (https://en.wikipedia.org/wiki/Mobile_country_code).
     * </pre>
     *
     * <code>optional string verification_key_id = 4;</code>
     * @param value The bytes for verificationKeyId to set.
     */
    private void setVerificationKeyIdBytes(
        com.google.protobuf.ByteString value) {
      verificationKeyId_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 5;
    private java.lang.String signatureAlgorithm_;
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    @java.lang.Override
    public boolean hasSignatureAlgorithm() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return The signatureAlgorithm.
     */
    @java.lang.Override
    public java.lang.String getSignatureAlgorithm() {
      return signatureAlgorithm_;
    }
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @return The bytes for signatureAlgorithm.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSignatureAlgorithmBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(signatureAlgorithm_);
    }
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @param value The signatureAlgorithm to set.
     */
    private void setSignatureAlgorithm(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000004;
      signatureAlgorithm_ = value;
    }
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     */
    private void clearSignatureAlgorithm() {
      bitField0_ = (bitField0_ & ~0x00000004);
      signatureAlgorithm_ = getDefaultInstance().getSignatureAlgorithm();
    }
    /**
     * <pre>
     * ASN.1 OID for Algorithm Identifier. Supported algorithms are
     * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
     * </pre>
     *
     * <code>optional string signature_algorithm = 5;</code>
     * @param value The bytes for signatureAlgorithm to set.
     */
    private void setSignatureAlgorithmBytes(
        com.google.protobuf.ByteString value) {
      signatureAlgorithm_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code SignatureInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:SignatureInfo)
        org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfoOrBuilder {
      // Construct using org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @return Whether the verificationKeyVersion field is set.
       */
      @java.lang.Override
      public boolean hasVerificationKeyVersion() {
        return instance.hasVerificationKeyVersion();
      }
      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @return The verificationKeyVersion.
       */
      @java.lang.Override
      public java.lang.String getVerificationKeyVersion() {
        return instance.getVerificationKeyVersion();
      }
      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @return The bytes for verificationKeyVersion.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getVerificationKeyVersionBytes() {
        return instance.getVerificationKeyVersionBytes();
      }
      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @param value The verificationKeyVersion to set.
       * @return This builder for chaining.
       */
      public Builder setVerificationKeyVersion(
          java.lang.String value) {
        copyOnWrite();
        instance.setVerificationKeyVersion(value);
        return this;
      }
      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerificationKeyVersion() {
        copyOnWrite();
        instance.clearVerificationKeyVersion();
        return this;
      }
      /**
       * <pre>
       * Key version for rollovers
       * Must be in character class [a-zA-Z0-9_]. E.g., 'v1'
       * </pre>
       *
       * <code>optional string verification_key_version = 3;</code>
       * @param value The bytes for verificationKeyVersion to set.
       * @return This builder for chaining.
       */
      public Builder setVerificationKeyVersionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVerificationKeyVersionBytes(value);
        return this;
      }

      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @return Whether the verificationKeyId field is set.
       */
      @java.lang.Override
      public boolean hasVerificationKeyId() {
        return instance.hasVerificationKeyId();
      }
      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @return The verificationKeyId.
       */
      @java.lang.Override
      public java.lang.String getVerificationKeyId() {
        return instance.getVerificationKeyId();
      }
      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @return The bytes for verificationKeyId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getVerificationKeyIdBytes() {
        return instance.getVerificationKeyIdBytes();
      }
      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @param value The verificationKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setVerificationKeyId(
          java.lang.String value) {
        copyOnWrite();
        instance.setVerificationKeyId(value);
        return this;
      }
      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerificationKeyId() {
        copyOnWrite();
        instance.clearVerificationKeyId();
        return this;
      }
      /**
       * <pre>
       * Alias with which to identify public key to be used for verification
       * Must be in character class [a-zA-Z0-9_]
       * For cross-compatibility with Apple, use MCC
       * (https://en.wikipedia.org/wiki/Mobile_country_code).
       * </pre>
       *
       * <code>optional string verification_key_id = 4;</code>
       * @param value The bytes for verificationKeyId to set.
       * @return This builder for chaining.
       */
      public Builder setVerificationKeyIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVerificationKeyIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @return Whether the signatureAlgorithm field is set.
       */
      @java.lang.Override
      public boolean hasSignatureAlgorithm() {
        return instance.hasSignatureAlgorithm();
      }
      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @return The signatureAlgorithm.
       */
      @java.lang.Override
      public java.lang.String getSignatureAlgorithm() {
        return instance.getSignatureAlgorithm();
      }
      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @return The bytes for signatureAlgorithm.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSignatureAlgorithmBytes() {
        return instance.getSignatureAlgorithmBytes();
      }
      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @param value The signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithm(
          java.lang.String value) {
        copyOnWrite();
        instance.setSignatureAlgorithm(value);
        return this;
      }
      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignatureAlgorithm() {
        copyOnWrite();
        instance.clearSignatureAlgorithm();
        return this;
      }
      /**
       * <pre>
       * ASN.1 OID for Algorithm Identifier. Supported algorithms are
       * either 1.2.840.10045.4.3.2 or 1.2.840.10045.4.3.4
       * </pre>
       *
       * <code>optional string signature_algorithm = 5;</code>
       * @param value The bytes for signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithmBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignatureAlgorithmBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:SignatureInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "verificationKeyVersion_",
              "verificationKeyId_",
              "signatureAlgorithm_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0003\u0005\u0003\u0000\u0000\u0000\u0003\u1008\u0000\u0004" +
                "\u1008\u0001\u0005\u1008\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo> parser = PARSER;
          if (parser == null) {
            synchronized (org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:SignatureInfo)
    private static final org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo DEFAULT_INSTANCE;
    static {
      SignatureInfo defaultInstance = new SignatureInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignatureInfo.class, defaultInstance);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignatureInfo> PARSER;

    public static com.google.protobuf.Parser<SignatureInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TemporaryExposureKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TemporaryExposureKey)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     * @return Whether the keyData field is set.
     */
    boolean hasKeyData();
    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     * @return The keyData.
     */
    com.google.protobuf.ByteString getKeyData();

    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     * @return Whether the transmissionRiskLevel field is set.
     */
    @java.lang.Deprecated boolean hasTransmissionRiskLevel();
    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     * @return The transmissionRiskLevel.
     */
    @java.lang.Deprecated int getTransmissionRiskLevel();

    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     * @return Whether the rollingStartIntervalNumber field is set.
     */
    boolean hasRollingStartIntervalNumber();
    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     * @return The rollingStartIntervalNumber.
     */
    int getRollingStartIntervalNumber();

    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     * @return Whether the rollingPeriod field is set.
     */
    boolean hasRollingPeriod();
    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     * @return The rollingPeriod.
     */
    int getRollingPeriod();

    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     * @return Whether the reportType field is set.
     */
    boolean hasReportType();
    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     * @return The reportType.
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType getReportType();

    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     * @return Whether the daysSinceOnsetOfSymptoms field is set.
     */
    boolean hasDaysSinceOnsetOfSymptoms();
    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     * @return The daysSinceOnsetOfSymptoms.
     */
    int getDaysSinceOnsetOfSymptoms();
  }
  /**
   * Protobuf type {@code TemporaryExposureKey}
   */
  public  static final class TemporaryExposureKey extends
      com.google.protobuf.GeneratedMessageLite<
          TemporaryExposureKey, TemporaryExposureKey.Builder> implements
      // @@protoc_insertion_point(message_implements:TemporaryExposureKey)
      TemporaryExposureKeyOrBuilder {
    private TemporaryExposureKey() {
      keyData_ = com.google.protobuf.ByteString.EMPTY;
      rollingPeriod_ = 144;
    }
    /**
     * <pre>
     * Data type representing why this key was published.
     * </pre>
     *
     * Protobuf enum {@code TemporaryExposureKey.ReportType}
     */
    public enum ReportType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Never returned by the client API.
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <code>CONFIRMED_TEST = 1;</code>
       */
      CONFIRMED_TEST(1),
      /**
       * <code>CONFIRMED_CLINICAL_DIAGNOSIS = 2;</code>
       */
      CONFIRMED_CLINICAL_DIAGNOSIS(2),
      /**
       * <code>SELF_REPORT = 3;</code>
       */
      SELF_REPORT(3),
      /**
       * <code>RECURSIVE = 4;</code>
       */
      RECURSIVE(4),
      /**
       * <pre>
       * Used to revoke a key, never returned by client API.
       * </pre>
       *
       * <code>REVOKED = 5;</code>
       */
      REVOKED(5),
      ;

      /**
       * <pre>
       * Never returned by the client API.
       * </pre>
       *
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <code>CONFIRMED_TEST = 1;</code>
       */
      public static final int CONFIRMED_TEST_VALUE = 1;
      /**
       * <code>CONFIRMED_CLINICAL_DIAGNOSIS = 2;</code>
       */
      public static final int CONFIRMED_CLINICAL_DIAGNOSIS_VALUE = 2;
      /**
       * <code>SELF_REPORT = 3;</code>
       */
      public static final int SELF_REPORT_VALUE = 3;
      /**
       * <code>RECURSIVE = 4;</code>
       */
      public static final int RECURSIVE_VALUE = 4;
      /**
       * <pre>
       * Used to revoke a key, never returned by client API.
       * </pre>
       *
       * <code>REVOKED = 5;</code>
       */
      public static final int REVOKED_VALUE = 5;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ReportType valueOf(int value) {
        return forNumber(value);
      }

      public static ReportType forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return CONFIRMED_TEST;
          case 2: return CONFIRMED_CLINICAL_DIAGNOSIS;
          case 3: return SELF_REPORT;
          case 4: return RECURSIVE;
          case 5: return REVOKED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ReportType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ReportType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ReportType>() {
              @java.lang.Override
              public ReportType findValueByNumber(int number) {
                return ReportType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ReportTypeVerifier.INSTANCE;
      }

      private static final class ReportTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ReportTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ReportType.forNumber(number) != null;
              }
            };

      private final int value;

      private ReportType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:TemporaryExposureKey.ReportType)
    }

    private int bitField0_;
    public static final int KEY_DATA_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString keyData_;
    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     * @return Whether the keyData field is set.
     */
    @java.lang.Override
    public boolean hasKeyData() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     * @return The keyData.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getKeyData() {
      return keyData_;
    }
    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     * @param value The keyData to set.
     */
    private void setKeyData(com.google.protobuf.ByteString value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      keyData_ = value;
    }
    /**
     * <pre>
     * Key of infected user
     * </pre>
     *
     * <code>optional bytes key_data = 1;</code>
     */
    private void clearKeyData() {
      bitField0_ = (bitField0_ & ~0x00000001);
      keyData_ = getDefaultInstance().getKeyData();
    }

    public static final int TRANSMISSION_RISK_LEVEL_FIELD_NUMBER = 2;
    private int transmissionRiskLevel_;
    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     * @return Whether the transmissionRiskLevel field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasTransmissionRiskLevel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     * @return The transmissionRiskLevel.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getTransmissionRiskLevel() {
      return transmissionRiskLevel_;
    }
    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     * @param value The transmissionRiskLevel to set.
     */
    private void setTransmissionRiskLevel(int value) {
      bitField0_ |= 0x00000002;
      transmissionRiskLevel_ = value;
    }
    /**
     * <pre>
     * Varying risks associated with exposure depending on type of verification
     * Ignored by the v1.5 client API when report_type is set.
     * </pre>
     *
     * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
     */
    private void clearTransmissionRiskLevel() {
      bitField0_ = (bitField0_ & ~0x00000002);
      transmissionRiskLevel_ = 0;
    }

    public static final int ROLLING_START_INTERVAL_NUMBER_FIELD_NUMBER = 3;
    private int rollingStartIntervalNumber_;
    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     * @return Whether the rollingStartIntervalNumber field is set.
     */
    @java.lang.Override
    public boolean hasRollingStartIntervalNumber() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     * @return The rollingStartIntervalNumber.
     */
    @java.lang.Override
    public int getRollingStartIntervalNumber() {
      return rollingStartIntervalNumber_;
    }
    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     * @param value The rollingStartIntervalNumber to set.
     */
    private void setRollingStartIntervalNumber(int value) {
      bitField0_ |= 0x00000004;
      rollingStartIntervalNumber_ = value;
    }
    /**
     * <pre>
     * The interval number since epoch for which a key starts
     * </pre>
     *
     * <code>optional int32 rolling_start_interval_number = 3;</code>
     */
    private void clearRollingStartIntervalNumber() {
      bitField0_ = (bitField0_ & ~0x00000004);
      rollingStartIntervalNumber_ = 0;
    }

    public static final int ROLLING_PERIOD_FIELD_NUMBER = 4;
    private int rollingPeriod_;
    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     * @return Whether the rollingPeriod field is set.
     */
    @java.lang.Override
    public boolean hasRollingPeriod() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     * @return The rollingPeriod.
     */
    @java.lang.Override
    public int getRollingPeriod() {
      return rollingPeriod_;
    }
    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     * @param value The rollingPeriod to set.
     */
    private void setRollingPeriod(int value) {
      bitField0_ |= 0x00000008;
      rollingPeriod_ = value;
    }
    /**
     * <pre>
     * Increments of 10 minutes describing how long a key is valid
     * </pre>
     *
     * <code>optional int32 rolling_period = 4 [default = 144];</code>
     */
    private void clearRollingPeriod() {
      bitField0_ = (bitField0_ & ~0x00000008);
      rollingPeriod_ = 144;
    }

    public static final int REPORT_TYPE_FIELD_NUMBER = 5;
    private int reportType_;
    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     * @return Whether the reportType field is set.
     */
    @java.lang.Override
    public boolean hasReportType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     * @return The reportType.
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType getReportType() {
      org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType result = org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType.forNumber(reportType_);
      return result == null ? org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType.UNKNOWN : result;
    }
    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     * @param value The reportType to set.
     */
    private void setReportType(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType value) {
      reportType_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Type of diagnosis associated with a key.
     * </pre>
     *
     * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
     */
    private void clearReportType() {
      bitField0_ = (bitField0_ & ~0x00000010);
      reportType_ = 0;
    }

    public static final int DAYS_SINCE_ONSET_OF_SYMPTOMS_FIELD_NUMBER = 6;
    private int daysSinceOnsetOfSymptoms_;
    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     * @return Whether the daysSinceOnsetOfSymptoms field is set.
     */
    @java.lang.Override
    public boolean hasDaysSinceOnsetOfSymptoms() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     * @return The daysSinceOnsetOfSymptoms.
     */
    @java.lang.Override
    public int getDaysSinceOnsetOfSymptoms() {
      return daysSinceOnsetOfSymptoms_;
    }
    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     * @param value The daysSinceOnsetOfSymptoms to set.
     */
    private void setDaysSinceOnsetOfSymptoms(int value) {
      bitField0_ |= 0x00000020;
      daysSinceOnsetOfSymptoms_ = value;
    }
    /**
     * <pre>
     * Number of days elapsed between symptom onset and the TEK being used.
     * E.g. 2 means TEK is 2 days after onset of symptoms.
     * </pre>
     *
     * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
     */
    private void clearDaysSinceOnsetOfSymptoms() {
      bitField0_ = (bitField0_ & ~0x00000020);
      daysSinceOnsetOfSymptoms_ = 0;
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code TemporaryExposureKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey, Builder> implements
        // @@protoc_insertion_point(builder_implements:TemporaryExposureKey)
        org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKeyOrBuilder {
      // Construct using org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Key of infected user
       * </pre>
       *
       * <code>optional bytes key_data = 1;</code>
       * @return Whether the keyData field is set.
       */
      @java.lang.Override
      public boolean hasKeyData() {
        return instance.hasKeyData();
      }
      /**
       * <pre>
       * Key of infected user
       * </pre>
       *
       * <code>optional bytes key_data = 1;</code>
       * @return The keyData.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getKeyData() {
        return instance.getKeyData();
      }
      /**
       * <pre>
       * Key of infected user
       * </pre>
       *
       * <code>optional bytes key_data = 1;</code>
       * @param value The keyData to set.
       * @return This builder for chaining.
       */
      public Builder setKeyData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyData(value);
        return this;
      }
      /**
       * <pre>
       * Key of infected user
       * </pre>
       *
       * <code>optional bytes key_data = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyData() {
        copyOnWrite();
        instance.clearKeyData();
        return this;
      }

      /**
       * <pre>
       * Varying risks associated with exposure depending on type of verification
       * Ignored by the v1.5 client API when report_type is set.
       * </pre>
       *
       * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
       * @return Whether the transmissionRiskLevel field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasTransmissionRiskLevel() {
        return instance.hasTransmissionRiskLevel();
      }
      /**
       * <pre>
       * Varying risks associated with exposure depending on type of verification
       * Ignored by the v1.5 client API when report_type is set.
       * </pre>
       *
       * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
       * @return The transmissionRiskLevel.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getTransmissionRiskLevel() {
        return instance.getTransmissionRiskLevel();
      }
      /**
       * <pre>
       * Varying risks associated with exposure depending on type of verification
       * Ignored by the v1.5 client API when report_type is set.
       * </pre>
       *
       * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
       * @param value The transmissionRiskLevel to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setTransmissionRiskLevel(int value) {
        copyOnWrite();
        instance.setTransmissionRiskLevel(value);
        return this;
      }
      /**
       * <pre>
       * Varying risks associated with exposure depending on type of verification
       * Ignored by the v1.5 client API when report_type is set.
       * </pre>
       *
       * <code>optional int32 transmission_risk_level = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearTransmissionRiskLevel() {
        copyOnWrite();
        instance.clearTransmissionRiskLevel();
        return this;
      }

      /**
       * <pre>
       * The interval number since epoch for which a key starts
       * </pre>
       *
       * <code>optional int32 rolling_start_interval_number = 3;</code>
       * @return Whether the rollingStartIntervalNumber field is set.
       */
      @java.lang.Override
      public boolean hasRollingStartIntervalNumber() {
        return instance.hasRollingStartIntervalNumber();
      }
      /**
       * <pre>
       * The interval number since epoch for which a key starts
       * </pre>
       *
       * <code>optional int32 rolling_start_interval_number = 3;</code>
       * @return The rollingStartIntervalNumber.
       */
      @java.lang.Override
      public int getRollingStartIntervalNumber() {
        return instance.getRollingStartIntervalNumber();
      }
      /**
       * <pre>
       * The interval number since epoch for which a key starts
       * </pre>
       *
       * <code>optional int32 rolling_start_interval_number = 3;</code>
       * @param value The rollingStartIntervalNumber to set.
       * @return This builder for chaining.
       */
      public Builder setRollingStartIntervalNumber(int value) {
        copyOnWrite();
        instance.setRollingStartIntervalNumber(value);
        return this;
      }
      /**
       * <pre>
       * The interval number since epoch for which a key starts
       * </pre>
       *
       * <code>optional int32 rolling_start_interval_number = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRollingStartIntervalNumber() {
        copyOnWrite();
        instance.clearRollingStartIntervalNumber();
        return this;
      }

      /**
       * <pre>
       * Increments of 10 minutes describing how long a key is valid
       * </pre>
       *
       * <code>optional int32 rolling_period = 4 [default = 144];</code>
       * @return Whether the rollingPeriod field is set.
       */
      @java.lang.Override
      public boolean hasRollingPeriod() {
        return instance.hasRollingPeriod();
      }
      /**
       * <pre>
       * Increments of 10 minutes describing how long a key is valid
       * </pre>
       *
       * <code>optional int32 rolling_period = 4 [default = 144];</code>
       * @return The rollingPeriod.
       */
      @java.lang.Override
      public int getRollingPeriod() {
        return instance.getRollingPeriod();
      }
      /**
       * <pre>
       * Increments of 10 minutes describing how long a key is valid
       * </pre>
       *
       * <code>optional int32 rolling_period = 4 [default = 144];</code>
       * @param value The rollingPeriod to set.
       * @return This builder for chaining.
       */
      public Builder setRollingPeriod(int value) {
        copyOnWrite();
        instance.setRollingPeriod(value);
        return this;
      }
      /**
       * <pre>
       * Increments of 10 minutes describing how long a key is valid
       * </pre>
       *
       * <code>optional int32 rolling_period = 4 [default = 144];</code>
       * @return This builder for chaining.
       */
      public Builder clearRollingPeriod() {
        copyOnWrite();
        instance.clearRollingPeriod();
        return this;
      }

      /**
       * <pre>
       * Type of diagnosis associated with a key.
       * </pre>
       *
       * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
       * @return Whether the reportType field is set.
       */
      @java.lang.Override
      public boolean hasReportType() {
        return instance.hasReportType();
      }
      /**
       * <pre>
       * Type of diagnosis associated with a key.
       * </pre>
       *
       * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
       * @return The reportType.
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType getReportType() {
        return instance.getReportType();
      }
      /**
       * <pre>
       * Type of diagnosis associated with a key.
       * </pre>
       *
       * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
       * @param value The enum numeric value on the wire for reportType to set.
       * @return This builder for chaining.
       */
      public Builder setReportType(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType value) {
        copyOnWrite();
        instance.setReportType(value);
        return this;
      }
      /**
       * <pre>
       * Type of diagnosis associated with a key.
       * </pre>
       *
       * <code>optional .TemporaryExposureKey.ReportType report_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearReportType() {
        copyOnWrite();
        instance.clearReportType();
        return this;
      }

      /**
       * <pre>
       * Number of days elapsed between symptom onset and the TEK being used.
       * E.g. 2 means TEK is 2 days after onset of symptoms.
       * </pre>
       *
       * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
       * @return Whether the daysSinceOnsetOfSymptoms field is set.
       */
      @java.lang.Override
      public boolean hasDaysSinceOnsetOfSymptoms() {
        return instance.hasDaysSinceOnsetOfSymptoms();
      }
      /**
       * <pre>
       * Number of days elapsed between symptom onset and the TEK being used.
       * E.g. 2 means TEK is 2 days after onset of symptoms.
       * </pre>
       *
       * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
       * @return The daysSinceOnsetOfSymptoms.
       */
      @java.lang.Override
      public int getDaysSinceOnsetOfSymptoms() {
        return instance.getDaysSinceOnsetOfSymptoms();
      }
      /**
       * <pre>
       * Number of days elapsed between symptom onset and the TEK being used.
       * E.g. 2 means TEK is 2 days after onset of symptoms.
       * </pre>
       *
       * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
       * @param value The daysSinceOnsetOfSymptoms to set.
       * @return This builder for chaining.
       */
      public Builder setDaysSinceOnsetOfSymptoms(int value) {
        copyOnWrite();
        instance.setDaysSinceOnsetOfSymptoms(value);
        return this;
      }
      /**
       * <pre>
       * Number of days elapsed between symptom onset and the TEK being used.
       * E.g. 2 means TEK is 2 days after onset of symptoms.
       * </pre>
       *
       * <code>optional sint32 days_since_onset_of_symptoms = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDaysSinceOnsetOfSymptoms() {
        copyOnWrite();
        instance.clearDaysSinceOnsetOfSymptoms();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:TemporaryExposureKey)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "keyData_",
              "transmissionRiskLevel_",
              "rollingStartIntervalNumber_",
              "rollingPeriod_",
              "reportType_",
              org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.ReportType.internalGetVerifier(),
              "daysSinceOnsetOfSymptoms_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0000\u0000\u0001\u100a\u0000\u0002" +
                "\u1004\u0001\u0003\u1004\u0002\u0004\u1004\u0003\u0005\u100c\u0004\u0006\u100f\u0005" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey> parser = PARSER;
          if (parser == null) {
            synchronized (org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:TemporaryExposureKey)
    private static final org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey DEFAULT_INSTANCE;
    static {
      TemporaryExposureKey defaultInstance = new TemporaryExposureKey();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TemporaryExposureKey.class, defaultInstance);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TemporaryExposureKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TemporaryExposureKey> PARSER;

    public static com.google.protobuf.Parser<TemporaryExposureKey> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TEKSignatureListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TEKSignatureList)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> 
        getSignaturesList();
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature getSignatures(int index);
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    int getSignaturesCount();
  }
  /**
   * Protobuf type {@code TEKSignatureList}
   */
  public  static final class TEKSignatureList extends
      com.google.protobuf.GeneratedMessageLite<
          TEKSignatureList, TEKSignatureList.Builder> implements
      // @@protoc_insertion_point(message_implements:TEKSignatureList)
      TEKSignatureListOrBuilder {
    private TEKSignatureList() {
      signatures_ = emptyProtobufList();
    }
    public static final int SIGNATURES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> signatures_;
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> getSignaturesList() {
      return signatures_;
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    public java.util.List<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureOrBuilder> 
        getSignaturesOrBuilderList() {
      return signatures_;
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    @java.lang.Override
    public int getSignaturesCount() {
      return signatures_.size();
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature getSignatures(int index) {
      return signatures_.get(index);
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureOrBuilder getSignaturesOrBuilder(
        int index) {
      return signatures_.get(index);
    }
    private void ensureSignaturesIsMutable() {
      com.google.protobuf.Internal.ProtobufList<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> tmp = signatures_;
      if (!tmp.isModifiable()) {
        signatures_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void setSignatures(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
      value.getClass();
  ensureSignaturesIsMutable();
      signatures_.set(index, value);
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void addSignatures(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
      value.getClass();
  ensureSignaturesIsMutable();
      signatures_.add(value);
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void addSignatures(
        int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
      value.getClass();
  ensureSignaturesIsMutable();
      signatures_.add(index, value);
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void addAllSignatures(
        java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> values) {
      ensureSignaturesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, signatures_);
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void clearSignatures() {
      signatures_ = emptyProtobufList();
    }
    /**
     * <code>repeated .TEKSignature signatures = 1;</code>
     */
    private void removeSignatures(int index) {
      ensureSignaturesIsMutable();
      signatures_.remove(index);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code TEKSignatureList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList, Builder> implements
        // @@protoc_insertion_point(builder_implements:TEKSignatureList)
        org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureListOrBuilder {
      // Construct using org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> getSignaturesList() {
        return java.util.Collections.unmodifiableList(
            instance.getSignaturesList());
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      @java.lang.Override
      public int getSignaturesCount() {
        return instance.getSignaturesCount();
      }/**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature getSignatures(int index) {
        return instance.getSignatures(index);
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
        copyOnWrite();
        instance.setSignatures(index, value);
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setSignatures(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder addSignatures(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
        copyOnWrite();
        instance.addSignatures(value);
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature value) {
        copyOnWrite();
        instance.addSignatures(index, value);
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder addSignatures(
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.Builder builderForValue) {
        copyOnWrite();
        instance.addSignatures(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.Builder builderForValue) {
        copyOnWrite();
        instance.addSignatures(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder addAllSignatures(
          java.lang.Iterable<? extends org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> values) {
        copyOnWrite();
        instance.addAllSignatures(values);
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder clearSignatures() {
        copyOnWrite();
        instance.clearSignatures();
        return this;
      }
      /**
       * <code>repeated .TEKSignature signatures = 1;</code>
       */
      public Builder removeSignatures(int index) {
        copyOnWrite();
        instance.removeSignatures(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:TEKSignatureList)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "signatures_",
              org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList> parser = PARSER;
          if (parser == null) {
            synchronized (org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:TEKSignatureList)
    private static final org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList DEFAULT_INSTANCE;
    static {
      TEKSignatureList defaultInstance = new TEKSignatureList();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TEKSignatureList.class, defaultInstance);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TEKSignatureList> PARSER;

    public static com.google.protobuf.Parser<TEKSignatureList> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TEKSignatureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TEKSignature)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     * @return Whether the signatureInfo field is set.
     */
    boolean hasSignatureInfo();
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     * @return The signatureInfo.
     */
    org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfo();

    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     * @return Whether the batchNum field is set.
     */
    boolean hasBatchNum();
    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     * @return The batchNum.
     */
    int getBatchNum();

    /**
     * <code>optional int32 batch_size = 3;</code>
     * @return Whether the batchSize field is set.
     */
    boolean hasBatchSize();
    /**
     * <code>optional int32 batch_size = 3;</code>
     * @return The batchSize.
     */
    int getBatchSize();

    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code TEKSignature}
   */
  public  static final class TEKSignature extends
      com.google.protobuf.GeneratedMessageLite<
          TEKSignature, TEKSignature.Builder> implements
      // @@protoc_insertion_point(message_implements:TEKSignature)
      TEKSignatureOrBuilder {
    private TEKSignature() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int SIGNATURE_INFO_FIELD_NUMBER = 1;
    private org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo signatureInfo_;
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     */
    @java.lang.Override
    public boolean hasSignatureInfo() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     */
    @java.lang.Override
    public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfo() {
      return signatureInfo_ == null ? org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.getDefaultInstance() : signatureInfo_;
    }
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     */
    private void setSignatureInfo(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
      value.getClass();
  signatureInfo_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeSignatureInfo(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
      value.getClass();
  if (signatureInfo_ != null &&
          signatureInfo_ != org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.getDefaultInstance()) {
        signatureInfo_ =
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.newBuilder(signatureInfo_).mergeFrom(value).buildPartial();
      } else {
        signatureInfo_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Info about the signing key, version, algorithm, etc.
     * </pre>
     *
     * <code>optional .SignatureInfo signature_info = 1;</code>
     */
    private void clearSignatureInfo() {  signatureInfo_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int BATCH_NUM_FIELD_NUMBER = 2;
    private int batchNum_;
    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     * @return Whether the batchNum field is set.
     */
    @java.lang.Override
    public boolean hasBatchNum() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     * @return The batchNum.
     */
    @java.lang.Override
    public int getBatchNum() {
      return batchNum_;
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     * @param value The batchNum to set.
     */
    private void setBatchNum(int value) {
      bitField0_ |= 0x00000002;
      batchNum_ = value;
    }
    /**
     * <pre>
     * E.g., Batch 2 of 10
     * </pre>
     *
     * <code>optional int32 batch_num = 2;</code>
     */
    private void clearBatchNum() {
      bitField0_ = (bitField0_ & ~0x00000002);
      batchNum_ = 0;
    }

    public static final int BATCH_SIZE_FIELD_NUMBER = 3;
    private int batchSize_;
    /**
     * <code>optional int32 batch_size = 3;</code>
     * @return Whether the batchSize field is set.
     */
    @java.lang.Override
    public boolean hasBatchSize() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional int32 batch_size = 3;</code>
     * @return The batchSize.
     */
    @java.lang.Override
    public int getBatchSize() {
      return batchSize_;
    }
    /**
     * <code>optional int32 batch_size = 3;</code>
     * @param value The batchSize to set.
     */
    private void setBatchSize(int value) {
      bitField0_ |= 0x00000004;
      batchSize_ = value;
    }
    /**
     * <code>optional int32 batch_size = 3;</code>
     */
    private void clearBatchSize() {
      bitField0_ = (bitField0_ & ~0x00000004);
      batchSize_ = 0;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      value.getClass();
  bitField0_ |= 0x00000008;
      signature_ = value;
    }
    /**
     * <pre>
     * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
     * </pre>
     *
     * <code>optional bytes signature = 4;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000008);
      signature_ = getDefaultInstance().getSignature();
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code TEKSignature}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature, Builder> implements
        // @@protoc_insertion_point(builder_implements:TEKSignature)
        org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignatureOrBuilder {
      // Construct using org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      @java.lang.Override
      public boolean hasSignatureInfo() {
        return instance.hasSignatureInfo();
      }
      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      @java.lang.Override
      public org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo getSignatureInfo() {
        return instance.getSignatureInfo();
      }
      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      public Builder setSignatureInfo(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
        copyOnWrite();
        instance.setSignatureInfo(value);
        return this;
        }
      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      public Builder setSignatureInfo(
          org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setSignatureInfo(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      public Builder mergeSignatureInfo(org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.SignatureInfo value) {
        copyOnWrite();
        instance.mergeSignatureInfo(value);
        return this;
      }
      /**
       * <pre>
       * Info about the signing key, version, algorithm, etc.
       * </pre>
       *
       * <code>optional .SignatureInfo signature_info = 1;</code>
       */
      public Builder clearSignatureInfo() {  copyOnWrite();
        instance.clearSignatureInfo();
        return this;
      }

      /**
       * <pre>
       * E.g., Batch 2 of 10
       * </pre>
       *
       * <code>optional int32 batch_num = 2;</code>
       * @return Whether the batchNum field is set.
       */
      @java.lang.Override
      public boolean hasBatchNum() {
        return instance.hasBatchNum();
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10
       * </pre>
       *
       * <code>optional int32 batch_num = 2;</code>
       * @return The batchNum.
       */
      @java.lang.Override
      public int getBatchNum() {
        return instance.getBatchNum();
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10
       * </pre>
       *
       * <code>optional int32 batch_num = 2;</code>
       * @param value The batchNum to set.
       * @return This builder for chaining.
       */
      public Builder setBatchNum(int value) {
        copyOnWrite();
        instance.setBatchNum(value);
        return this;
      }
      /**
       * <pre>
       * E.g., Batch 2 of 10
       * </pre>
       *
       * <code>optional int32 batch_num = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchNum() {
        copyOnWrite();
        instance.clearBatchNum();
        return this;
      }

      /**
       * <code>optional int32 batch_size = 3;</code>
       * @return Whether the batchSize field is set.
       */
      @java.lang.Override
      public boolean hasBatchSize() {
        return instance.hasBatchSize();
      }
      /**
       * <code>optional int32 batch_size = 3;</code>
       * @return The batchSize.
       */
      @java.lang.Override
      public int getBatchSize() {
        return instance.getBatchSize();
      }
      /**
       * <code>optional int32 batch_size = 3;</code>
       * @param value The batchSize to set.
       * @return This builder for chaining.
       */
      public Builder setBatchSize(int value) {
        copyOnWrite();
        instance.setBatchSize(value);
        return this;
      }
      /**
       * <code>optional int32 batch_size = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchSize() {
        copyOnWrite();
        instance.clearBatchSize();
        return this;
      }

      /**
       * <pre>
       * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
       * </pre>
       *
       * <code>optional bytes signature = 4;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <pre>
       * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
       * </pre>
       *
       * <code>optional bytes signature = 4;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
       * </pre>
       *
       * <code>optional bytes signature = 4;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * Signature in X9.62 format (ASN.1 SEQUENCE of two INTEGER fields)
       * </pre>
       *
       * <code>optional bytes signature = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:TEKSignature)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "signatureInfo_",
              "batchNum_",
              "batchSize_",
              "signature_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u1009\u0000\u0002" +
                "\u1004\u0001\u0003\u1004\u0002\u0004\u100a\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature> parser = PARSER;
          if (parser == null) {
            synchronized (org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:TEKSignature)
    private static final org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature DEFAULT_INSTANCE;
    static {
      TEKSignature defaultInstance = new TEKSignature();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TEKSignature.class, defaultInstance);
    }

    public static org.tosl.coronawarncompanion.diagnosiskeys.DiagnosisKeysProtos.TEKSignature getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TEKSignature> PARSER;

    public static com.google.protobuf.Parser<TEKSignature> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
